{"version":3,"sources":["meteor://ðŸ’»app/packages/jalik_ufs/ufs.js","meteor://ðŸ’»app/packages/jalik_ufs/ufs-config.js","meteor://ðŸ’»app/packages/jalik_ufs/ufs-filter.js","meteor://ðŸ’»app/packages/jalik_ufs/ufs-store.js","meteor://ðŸ’»app/packages/jalik_ufs/ufs-methods.js","meteor://ðŸ’»app/packages/jalik_ufs/ufs-server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;ACxbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H;;;;;;;;;;;;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6H","file":"/packages/jalik_ufs.js","sourcesContent":["var stores = {};\n\nUploadFS = {\n    /**\n     * Contains all stores\n     */\n    store: {},\n    /**\n     * Returns the temporary file path\n     * @param fileId\n     * @return {string}\n     */\n    getTempFilePath: function (fileId) {\n        return UploadFS.config.tmpDir + '/' + fileId;\n    },\n    /**\n     * Returns the store by its name\n     * @param name\n     * @return {UploadFS.Store}\n     */\n    getStore: function (name) {\n        return stores[name];\n    },\n    /**\n     * Returns all stores\n     * @return {object}\n     */\n    getStores: function () {\n        return stores;\n    },\n    /**\n     * Imports a file from a URL\n     * @param url\n     * @param file\n     * @param store\n     * @param callback\n     */\n    importFromURL: function (url, file, store, callback) {\n        Meteor.call('ufsImportURL', url, file, store && store.getName(), callback);\n    }\n};\n\nif (Meteor.isServer) {\n    /**\n     * Generates a random token using a pattern (xy)\n     * @param pattern\n     * @return {string}\n     */\n    UploadFS.generateToken = function (pattern) {\n        return (pattern || 'xyxyxyxyxy').replace(/[xy]/g, function (c) {\n            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n            var s = v.toString(16);\n            return Math.round(Math.random()) ? s.toUpperCase() : s;\n        });\n    };\n}\n\nif (Meteor.isClient) {\n    /**\n     * Returns file and data as ArrayBuffer for each files in the event\n     * @param event\n     * @param callback\n     */\n    UploadFS.readAsArrayBuffer = function (event, callback) {\n        if (typeof callback !== 'function') {\n            throw new TypeError('callback is not a function');\n        }\n\n        var files = event.target.files;\n\n        for (var i = 0; i < files.length; i += 1) {\n            var file = files[i];\n\n            (function (file) {\n                var reader = new FileReader();\n                reader.onload = function (ev) {\n                    callback.call(UploadFS, ev.target.result, file);\n                };\n                reader.readAsArrayBuffer(file);\n            })(file);\n        }\n    };\n\n    /**\n     * Opens the browser's file selection dialog\n     * @param callback\n     */\n    UploadFS.selectFiles = function (callback) {\n        var img = document.createElement('input');\n        img.type = 'file';\n        img.onchange = callback;\n        img.click();\n    }\n}\n","/**\n * UploadFS configuration\n * @param options\n * @constructor\n */\nUploadFS.Config = function (options) {\n    // Set default options\n    options = _.extend({\n        https: false,\n        simulateReadDelay: 0,\n        simulateUploadSpeed: 0,\n        simulateWriteDelay: 0,\n        storesPath: 'ufs',\n        tmpDir: '/tmp/ufs'\n    }, options);\n\n    // Check options\n    if (typeof options.https !== 'boolean') {\n        throw new TypeError('https is not a function');\n    }\n    if (typeof options.simulateReadDelay !== 'number') {\n        throw new Meteor.Error('simulateReadDelay is not a number');\n    }\n    if (typeof options.simulateUploadSpeed !== 'number') {\n        throw new Meteor.Error('simulateUploadSpeed is not a number');\n    }\n    if (typeof options.simulateWriteDelay !== 'number') {\n        throw new Meteor.Error('simulateWriteDelay is not a number');\n    }\n    if (typeof options.storesPath !== 'string') {\n        throw new Meteor.Error('storesPath is not a string');\n    }\n    if (typeof options.tmpDir !== 'string') {\n        throw new Meteor.Error('tmpDir is not a string');\n    }\n\n    // Public attributes\n    this.https = options.https;\n    this.simulateReadDelay = parseInt(options.simulateReadDelay);\n    this.simulateUploadSpeed = parseInt(options.simulateUploadSpeed);\n    this.simulateWriteDelay = parseInt(options.simulateWriteDelay);\n    this.storesPath = options.storesPath;\n    this.tmpDir = options.tmpDir;\n};\n\n/**\n * Simulation read delay in milliseconds\n * @type {number}\n */\nUploadFS.Config.prototype.simulateReadDelay = 0;\n\n/**\n * Simulation upload speed in milliseconds\n * @type {number}\n */\nUploadFS.Config.prototype.simulateUploadSpeed = 0;\n\n/**\n * Simulation write delay in milliseconds\n * @type {number}\n */\nUploadFS.Config.prototype.simulateWriteDelay = 0;\n\n/**\n * URL path to stores\n * @type {string}\n */\nUploadFS.Config.prototype.storesPath = null;\n\n/**\n * Local temporary directory for uploading files\n * @type {string}\n */\nUploadFS.Config.prototype.tmpDir = null;\n\n/**\n * Global configuration\n * @type {UploadFS.Config}\n */\nUploadFS.config = new UploadFS.Config();\n","/**\n * File filter\n * @param options\n * @constructor\n */\nUploadFS.Filter = function (options) {\n    var self = this;\n\n    // Set default options\n    options = _.extend({\n        contentTypes: null,\n        extensions: null,\n        minSize: 1,\n        maxSize: 0,\n        onCheck: null\n    }, options);\n\n    // Check options\n    if (options.contentTypes && !(options.contentTypes instanceof Array)) {\n        throw new TypeError('contentTypes is not an Array');\n    }\n    if (options.extensions && !(options.extensions instanceof Array)) {\n        throw new TypeError('extensions is not an Array');\n    }\n    if (typeof options.minSize !== 'number') {\n        throw new TypeError('minSize is not a number');\n    }\n    if (typeof options.maxSize !== 'number') {\n        throw new TypeError('maxSize is not a number');\n    }\n    if (options.onCheck && typeof options.onCheck !== 'function') {\n        throw new TypeError('onCheck is not a function');\n    }\n\n    // Private attributes\n    var contentTypes = options.contentTypes;\n    var extensions = options.extensions;\n    var onCheck = options.onCheck;\n    var maxSize = parseInt(options.maxSize);\n    var minSize = parseInt(options.minSize);\n\n    /**\n     * Checks the file\n     * @param file\n     */\n    self.check = function (file) {\n        // Check size\n        if (file.size <= 0 || file.size < self.getMinSize()) {\n            throw new Meteor.Error('file-too-small', 'File is too small (min =' + self.getMinSize() + ')');\n        }\n        if (self.getMaxSize() > 0 && file.size > self.getMaxSize()) {\n            throw new Meteor.Error('file-too-large', 'File is too large (max = ' + self.getMaxSize() + ')');\n        }\n        // Check extension\n        if (self.getExtensions() && !_.contains(self.getExtensions(), file.extension)) {\n            throw new Meteor.Error('invalid-file-extension', 'File extension is not accepted');\n        }\n        // Check content type\n        if (self.getContentTypes() && !checkContentType(file.type, self.getContentTypes())) {\n            throw new Meteor.Error('invalid-file-type', 'File type is not accepted');\n        }\n        // Apply custom check\n        if (typeof onCheck === 'function' && !onCheck.call(self, file)) {\n            throw new Meteor.Error('invalid-file', 'File does not match filter');\n        }\n    };\n\n    /**\n     * Returns the allowed content types\n     * @return {Array}\n     */\n    self.getContentTypes = function () {\n        return contentTypes;\n    };\n\n    /**\n     * Returns the allowed extensions\n     * @return {Array}\n     */\n    self.getExtensions = function () {\n        return extensions;\n    };\n\n    /**\n     * Returns the maximum file size\n     * @return {Number}\n     */\n    self.getMaxSize = function () {\n        return maxSize;\n    };\n\n    /**\n     * Returns the minimum file size\n     * @return {Number}\n     */\n    self.getMinSize = function () {\n        return minSize;\n    };\n\n    /**\n     * Checks if the file matches filter\n     * @param file\n     * @return {boolean}\n     */\n    self.isValid = function (file) {\n        return !(\n            file.size <= 0 || file.size < self.getMinSize()\n            || self.getMaxSize() > 0 && file.size > self.getMaxSize()\n            || self.getExtensions() && !_.contains(self.getExtensions(), file.extension)\n            || self.getContentTypes() && !checkContentType(file.type, self.getContentTypes())\n            || (typeof onCheck === 'function' && !onCheck.call(self, file))\n        );\n    };\n};\n\nfunction checkContentType(type, list) {\n    if (_.contains(list, type)) {\n        return true;\n    } else {\n        var wildCardGlob = '/*';\n        var wildcards = _.filter(list, function (item) {\n            return item.indexOf(wildCardGlob) > 0;\n        });\n\n        if (_.contains(wildcards, type.replace(/(\\/.*)$/, wildCardGlob))) {\n            return true;\n        }\n    }\n    return false;\n}\n","/**\n * File store\n * @param options\n * @constructor\n */\nUploadFS.Store = function (options) {\n    var self = this;\n\n    // Set default options\n    options = _.extend({\n        collection: null,\n        filter: null,\n        name: null,\n        onCopyError: null,\n        onFinishUpload: null,\n        onRead: null,\n        onReadError: null,\n        onWriteError: null,\n        transformRead: null,\n        transformWrite: null\n    }, options);\n\n    // Check instance\n    if (!(self instanceof UploadFS.Store)) {\n        throw new Error('UploadFS.Store is not an instance');\n    }\n\n    // Check options\n    if (!(options.collection instanceof Mongo.Collection)) {\n        throw new TypeError('collection is not a Mongo.Collection');\n    }\n    if (options.filter && !(options.filter instanceof UploadFS.Filter)) {\n        throw new TypeError('filter is not an UploadFS.Filter');\n    }\n    if (typeof options.name !== 'string') {\n        throw new TypeError('name is not a string');\n    }\n    if (UploadFS.getStore(options.name)) {\n        throw new TypeError('name already exists');\n    }\n    if (options.onCopyError && typeof options.onCopyError !== 'function') {\n        throw new TypeError('onCopyError is not a function');\n    }\n    if (options.onFinishUpload && typeof options.onFinishUpload !== 'function') {\n        throw new TypeError('onFinishUpload is not a function');\n    }\n    if (options.onRead && typeof options.onRead !== 'function') {\n        throw new TypeError('onRead is not a function');\n    }\n    if (options.onReadError && typeof options.onReadError !== 'function') {\n        throw new TypeError('onReadError is not a function');\n    }\n    if (options.onWriteError && typeof options.onWriteError !== 'function') {\n        throw new TypeError('onWriteError is not a function');\n    }\n    if (options.transformRead && typeof options.transformRead !== 'function') {\n        throw new TypeError('transformRead is not a function');\n    }\n    if (options.transformWrite && typeof options.transformWrite !== 'function') {\n        throw new TypeError('transformWrite is not a function');\n    }\n\n    // Public attributes\n    self.onCopyError = options.onCopyError || self.onCopyError;\n    self.onFinishUpload = options.onFinishUpload || self.onFinishUpload;\n    self.onRead = options.onRead || self.onRead;\n    self.onReadError = options.onReadError || self.onReadError;\n    self.onWriteError = options.onWriteError || self.onWriteError;\n\n    // Private attributes\n    var collection = options.collection;\n    var copyTo = options.copyTo;\n    var filter = options.filter;\n    var name = options.name;\n    var transformRead = options.transformRead;\n    var transformWrite = options.transformWrite;\n\n    // Add the store to the list\n    UploadFS.getStores()[name] = self;\n\n    /**\n     * Creates the file in the collection\n     * @param file\n     * @return {string}\n     */\n    self.create = function (file) {\n        check(file, Object);\n        file.store = name;\n        return self.getCollection().insert(file);\n    };\n\n    /**\n     * Returns the collection\n     * @return {Mongo.Collection}\n     */\n    self.getCollection = function () {\n        return collection;\n    };\n\n    /**\n     * Returns the file filter\n     * @return {UploadFS.Filter}\n     */\n    self.getFilter = function () {\n        return filter;\n    };\n\n    /**\n     * Returns the store name\n     * @return {string}\n     */\n    self.getName = function () {\n        return name;\n    };\n\n\n    if (Meteor.isServer) {\n\n        /**\n         * Copies the file to a store\n         * @param fileId\n         * @param store\n         * @param callback\n         */\n        self.copy = function (fileId, store, callback) {\n            check(fileId, String);\n\n            if (!(store instanceof UploadFS.Store)) {\n                throw new TypeError('store is not an UploadFS.store.Store');\n            }\n\n            // Get original file\n            var file = self.getCollection().findOne(fileId);\n            if (!file) {\n                throw new Meteor.Error(404, 'File not found');\n            }\n\n            // Prepare copy\n            var copy = _.omit(file, '_id', 'url');\n            copy.originalStore = self.getName();\n            copy.originalId = fileId;\n\n            // Create the copy\n            var copyId = store.create(copy);\n\n            // Get original stream\n            var rs = self.getReadStream(fileId, file);\n\n            // Catch errors to avoid app crashing\n            rs.on('error', Meteor.bindEnvironment(function (error) {\n                callback.call(self, error, null);\n            }));\n\n            // Copy file data\n            store.write(rs, copyId, Meteor.bindEnvironment(function (err) {\n                if (err) {\n                    store.getCollection().remove(copyId);\n                    self.onCopyError.call(self, err, fileId, file);\n                }\n                if (typeof callback === 'function') {\n                    callback.call(self, err, copyId, copy, store);\n                }\n            }));\n        };\n\n        /**\n         * Transforms the file on reading\n         * @param readStream\n         * @param writeStream\n         * @param fileId\n         * @param file\n         * @param request\n         * @param headers\n         */\n        self.transformRead = function (readStream, writeStream, fileId, file, request, headers) {\n            if (typeof transformRead === 'function') {\n                transformRead.call(self, readStream, writeStream, fileId, file, request, headers);\n            } else {\n                readStream.pipe(writeStream);\n            }\n        };\n\n        /**\n         * Transforms the file on writing\n         * @param readStream\n         * @param writeStream\n         * @param fileId\n         * @param file\n         */\n        self.transformWrite = function (readStream, writeStream, fileId, file) {\n            if (typeof transformWrite === 'function') {\n                transformWrite.call(self, readStream, writeStream, fileId, file);\n            } else {\n                readStream.pipe(writeStream);\n            }\n        };\n\n        /**\n         * Writes the file to the store\n         * @param rs\n         * @param fileId\n         * @param callback\n         */\n        self.write = function (rs, fileId, callback) {\n            var file = self.getCollection().findOne(fileId);\n            var ws = self.getWriteStream(fileId, file);\n\n            var errorHandler = Meteor.bindEnvironment(function (err) {\n                self.getCollection().remove(fileId);\n                self.onWriteError.call(self, err, fileId, file);\n                callback.call(self, err);\n            });\n\n            ws.on('error', errorHandler);\n            ws.on('finish', Meteor.bindEnvironment(function () {\n                var size = 0;\n                var readStream = self.getReadStream(fileId, file);\n\n                readStream.on('error', Meteor.bindEnvironment(function (error) {\n                    callback.call(self, error, null);\n                }));\n                readStream.on('data', Meteor.bindEnvironment(function (data) {\n                    size += data.length;\n                }));\n                readStream.on('end', Meteor.bindEnvironment(function () {\n                    // Set file attribute\n                    file.complete = true;\n                    file.progress = 1;\n                    file.size = size;\n                    file.token = UploadFS.generateToken();\n                    file.uploading = false;\n                    file.uploadedAt = new Date();\n                    file.url = self.getFileURL(fileId);\n\n                    // Sets the file URL when file transfer is complete,\n                    // this way, the image will loads entirely.\n                    self.getCollection().update(fileId, {\n                        $set: {\n                            complete: file.complete,\n                            progress: file.progress,\n                            size: file.size,\n                            token: file.token,\n                            uploading: file.uploading,\n                            uploadedAt: file.uploadedAt,\n                            url: file.url\n                        }\n                    });\n\n                    // Return file info\n                    callback.call(self, null, file);\n\n                    // Execute callback\n                    if (typeof self.onFinishUpload == 'function') {\n                        self.onFinishUpload.call(self, file);\n                    }\n\n                    // Simulate write speed\n                    if (UploadFS.config.simulateWriteDelay) {\n                        Meteor._sleepForMs(UploadFS.config.simulateWriteDelay);\n                    }\n\n                    // Copy file to other stores\n                    if (copyTo instanceof Array) {\n                        for (var i = 0; i < copyTo.length; i += 1) {\n                            var store = copyTo[i];\n\n                            if (!store.getFilter() || store.getFilter().isValid(file)) {\n                                self.copy(fileId, store);\n                            }\n                        }\n                    }\n                }));\n            }));\n\n            // Execute transformation\n            self.transformWrite(rs, ws, fileId, file);\n        };\n    }\n\n    // Code executed before inserting file\n    collection.before.insert(function (userId, file) {\n        if (typeof file.name !== 'string' || !file.name.length) {\n            throw new Meteor.Error(400, \"file name not defined\");\n        }\n        if (typeof file.store !== 'string' || !file.store.length) {\n            throw new Meteor.Error(400, \"file store not defined\");\n        }\n        if (typeof file.complete !== 'boolean') {\n            file.complete = false;\n        }\n        if (typeof file.uploading !== 'boolean') {\n            file.uploading = true;\n        }\n        file.extension = file.name && file.name.substr((~-file.name.lastIndexOf('.') >>> 0) + 2).toLowerCase();\n        file.progress = parseFloat(file.progress) || 0;\n        file.size = parseInt(file.size) || 0;\n        file.userId = file.userId || userId;\n    });\n\n    // Code executed after removing file\n    collection.after.remove(function (userId, file) {\n        if (Meteor.isServer) {\n            if (copyTo instanceof Array) {\n                for (var i = 0; i < copyTo.length; i += 1) {\n                    // Remove copies in stores\n                    copyTo[i].getCollection().remove({originalId: file._id});\n                }\n            }\n        }\n    });\n\n    // Code executed before removing file\n    collection.before.remove(function (userId, file) {\n        if (Meteor.isServer) {\n            // Delete the physical file in the store\n            self.delete(file._id);\n\n            var tmpFile = UploadFS.getTempFilePath(file._id);\n\n            // Delete the temp file\n            fs.stat(tmpFile, function (err) {\n                !err && fs.unlink(tmpFile, function (err) {\n                    err && console.error('ufs: cannot delete temp file at ' + tmpFile + ' (' + err.message + ')');\n                });\n            });\n        }\n    });\n\n    collection.deny({\n        // Test filter on file insertion\n        insert: function (userId, file) {\n            if (filter instanceof UploadFS.Filter) {\n                filter.check(file);\n            }\n            return typeof options.insert === 'function'\n                && !options.insert.apply(this, arguments);\n        }\n    });\n};\n\n/**\n * Returns the file URL\n * @param fileId\n */\nUploadFS.Store.prototype.getFileURL = function (fileId) {\n    var file = this.getCollection().findOne(fileId, {\n        fields: {name: 1}\n    });\n    return file && this.getURL() + '/' + fileId + '/' + encodeURIComponent(file.name);\n};\n\n/**\n * Returns the store URL\n */\nUploadFS.Store.prototype.getURL = function () {\n    return Meteor.absoluteUrl(UploadFS.config.storesPath + '/' + this.getName(), {\n        secure: UploadFS.config.https\n    });\n};\n\nif (Meteor.isServer) {\n    /**\n     * Deletes a file async\n     * @param fileId\n     * @param callback\n     */\n    UploadFS.Store.prototype.delete = function (fileId, callback) {\n        throw new Error('delete is not implemented');\n    };\n\n    /**\n     * Returns the file read stream\n     * @param fileId\n     * @param file\n     */\n    UploadFS.Store.prototype.getReadStream = function (fileId, file) {\n        throw new Error('getReadStream is not implemented');\n    };\n\n    /**\n     * Returns the file write stream\n     * @param fileId\n     * @param file\n     */\n    UploadFS.Store.prototype.getWriteStream = function (fileId, file) {\n        throw new Error('getWriteStream is not implemented');\n    };\n\n    /**\n     * Callback for copy errors\n     * @param err\n     * @param fileId\n     * @param file\n     * @return boolean\n     */\n    UploadFS.Store.prototype.onCopyError = function (err, fileId, file) {\n        console.error('ufs: cannot copy file \"' + fileId + '\" (' + err.message + ')');\n    };\n\n    /**\n     * Called when a file has been uploaded\n     * @param file\n     */\n    UploadFS.Store.prototype.onFinishUpload = function (file) {\n    };\n\n    /**\n     * Called when a file is read from the store\n     * @param fileId\n     * @param file\n     * @param request\n     * @param response\n     * @return boolean\n     */\n    UploadFS.Store.prototype.onRead = function (fileId, file, request, response) {\n        return true;\n    };\n\n    /**\n     * Callback for read errors\n     * @param err\n     * @param fileId\n     * @param file\n     * @return boolean\n     */\n    UploadFS.Store.prototype.onReadError = function (err, fileId, file) {\n        console.error('ufs: cannot read file \"' + fileId + '\" (' + err.message + ')');\n    };\n\n    /**\n     * Callback for write errors\n     * @param err\n     * @param fileId\n     * @param file\n     * @return boolean\n     */\n    UploadFS.Store.prototype.onWriteError = function (err, fileId, file) {\n        console.error('ufs: cannot write file \"' + fileId + '\" (' + err.message + ')');\n    };\n}\n","Meteor.methods({\n\n    /**\n     * Completes the file transfer\n     * @param fileId\n     * @param storeName\n     */\n    ufsComplete: function (fileId, storeName) {\n        check(fileId, String);\n        check(storeName, String);\n\n        // Allow other uploads to run concurrently\n        this.unblock();\n\n        var store = UploadFS.getStore(storeName);\n        if (!store) {\n            throw new Meteor.Error(404, 'store \"' + storeName + '\" does not exist');\n        }\n        // Check that file exists and is owned by current user\n        if (store.getCollection().find({_id: fileId, userId: this.userId}).count() < 1) {\n            throw new Meteor.Error(404, 'file \"' + fileId + '\" does not exist');\n        }\n\n        var fut = new Future();\n        var tmpFile = UploadFS.getTempFilePath(fileId);\n\n        // Get the temp file\n        var rs = fs.createReadStream(tmpFile, {\n            flags: 'r',\n            encoding: null,\n            autoClose: true\n        });\n\n        rs.on('error', Meteor.bindEnvironment(function () {\n            store.getCollection().remove(fileId);\n        }));\n\n        // Save file in the store\n        store.write(rs, fileId, Meteor.bindEnvironment(function (err, file) {\n            fs.unlink(tmpFile, function (err) {\n                err && console.error('ufs: cannot delete temp file ' + tmpFile + ' (' + err.message + ')');\n            });\n\n            if (err) {\n                fut.throw(err);\n            } else {\n                fut.return(file);\n            }\n        }));\n        return fut.wait();\n    },\n\n    /**\n     * Imports a file from the URL\n     * @param url\n     * @param file\n     * @param storeName\n     * @return {*}\n     */\n    ufsImportURL: function (url, file, storeName) {\n        check(url, String);\n        check(file, Object);\n        check(storeName, String);\n\n        this.unblock();\n\n        var store = UploadFS.getStore(storeName);\n        if (!store) {\n            throw new Meteor.Error(404, 'Store \"' + storeName + '\" does not exist');\n        }\n\n        try {\n            // Extract file info\n            if (!file.name) {\n                file.name = url.replace(/\\?.*$/, '').split('/').pop();\n                file.extension = file.name.split('.').pop();\n                file.type = 'image/' + file.extension;\n            }\n            // Check if file is valid\n            if (store.getFilter() instanceof UploadFS.Filter) {\n                store.getFilter().check(file);\n            }\n            // Create the file\n            var fileId = store.create(file);\n\n        } catch (err) {\n            throw new Meteor.Error(500, err.message);\n        }\n\n        var fut = new Future();\n        var proto;\n\n        // Detect protocol to use\n        if (/http:\\/\\//i.test(url)) {\n            proto = http;\n        } else if (/https:\\/\\//i.test(url)) {\n            proto = https;\n        }\n\n        // Download file\n        proto.get(url, Meteor.bindEnvironment(function (res) {\n            // Save the file in the store\n            store.write(res, fileId, function (err, file) {\n                if (err) {\n                    fut.throw(err);\n                } else {\n                    fut.return(fileId);\n                }\n            });\n        })).on('error', function (err) {\n            fut.throw(err);\n        });\n        return fut.wait();\n    },\n\n    /**\n     * Saves a chunk of file\n     * @param chunk\n     * @param fileId\n     * @param storeName\n     * @param progress\n     * @return {*}\n     */\n    ufsWrite: function (chunk, fileId, storeName, progress) {\n        check(fileId, String);\n        check(storeName, String);\n        check(progress, Number);\n\n        this.unblock();\n\n        // Check arguments\n        if (!(chunk instanceof Uint8Array)) {\n            throw new Meteor.Error(400, 'chunk is not an Uint8Array');\n        }\n        if (chunk.length <= 0) {\n            throw new Meteor.Error(400, 'chunk is empty');\n        }\n\n        var store = UploadFS.getStore(storeName);\n        if (!store) {\n            throw new Meteor.Error(404, 'store ' + storeName + ' does not exist');\n        }\n\n        // Check that file exists, is not complete and is owned by current user\n        if (store.getCollection().find({_id: fileId, complete: false, userId: this.userId}).count() < 1) {\n            throw new Meteor.Error(404, 'file ' + fileId + ' does not exist');\n        }\n\n        var fut = new Future();\n        var tmpFile = UploadFS.getTempFilePath(fileId);\n\n        // Save the chunk\n        fs.appendFile(tmpFile, new Buffer(chunk), Meteor.bindEnvironment(function (err) {\n            if (err) {\n                console.error('ufs: cannot write chunk of file \"' + fileId + '\" (' + err.message + ')');\n                fs.unlink(tmpFile, function (err) {\n                    err && console.error('ufs: cannot delete temp file ' + tmpFile + ' (' + err.message + ')');\n                });\n                fut.throw(err);\n            } else {\n                // Update completed state\n                store.getCollection().update(fileId, {\n                    $set: {progress: progress}\n                });\n                fut.return(chunk.length);\n            }\n        }));\n        return fut.wait();\n    }\n});\n","domain = Npm.require('domain');\nfs = Npm.require('fs');\nFuture = Npm.require('fibers/future');\nhttp = Npm.require('http');\nhttps = Npm.require('https');\nmkdirp = Npm.require('mkdirp');\nstream = Npm.require('stream');\nzlib = Npm.require('zlib');\n\nMeteor.startup(function () {\n    var path = UploadFS.config.tmpDir;\n    var mode = '0744';\n\n    fs.stat(path, function (err) {\n        if (err) {\n            // Create the temp directory\n            mkdirp(path, {mode: mode}, function (err) {\n                if (err) {\n                    console.error('ufs: cannot create temp directory at ' + path + ' (' + err.message + ')');\n                } else {\n                    console.log('ufs: temp directory created at ' + path);\n                }\n            });\n        } else {\n            // Set directory permissions\n            fs.chmod(path, mode, function (err) {\n                err && console.error('ufs: cannot set temp directory permissions ' + mode + ' (' + err.message + ')');\n            });\n        }\n    });\n});\n\n// Create domain to handle errors\n// and possibly avoid server crashes.\nvar d = domain.create();\n\nd.on('error', function (err) {\n    console.error('ufs: ' + err.message);\n});\n\n// Listen HTTP requests to serve files\nWebApp.connectHandlers.use(function (req, res, next) {\n    // Quick check to see if request should be catch\n    if (req.url.indexOf(UploadFS.config.storesPath) === -1) {\n        next();\n        return;\n    }\n\n    // Remove store path\n    var path = req.url.substr(UploadFS.config.storesPath.length + 1);\n\n    // Get store, file Id and file name\n    var regExp = new RegExp('^\\/([^\\/]+)\\/([^\\/]+)(?:\\/([^\\/]+))?$');\n    var match = regExp.exec(path);\n\n    if (match !== null) {\n        // Get store\n        var storeName = match[1];\n        var store = UploadFS.getStore(storeName);\n\n        if (!store) {\n            res.writeHead(404);\n            res.end();\n            return;\n        }\n\n        if (typeof store.onRead !== 'function') {\n            console.error('ufs: store \"' + storeName + '\" onRead is not a function');\n            res.writeHead(500);\n            res.end();\n            return;\n        }\n\n        // Remove file extension from file Id\n        var index = match[2].indexOf('.');\n        var fileId = index !== -1 ? match[2].substr(0, index) : match[2];\n\n        // Get file from database\n        var file = store.getCollection().findOne(fileId);\n        if (!file) {\n            res.writeHead(404);\n            res.end();\n            return;\n        }\n\n        // Simulate read speed\n        if (UploadFS.config.simulateReadDelay) {\n            Meteor._sleepForMs(UploadFS.config.simulateReadDelay);\n        }\n\n        d.run(function () {\n            // Check if the file can be accessed\n            if (store.onRead.call(store, fileId, file, req, res)) {\n                // Open the file stream\n                var rs = store.getReadStream(fileId, file);\n                var ws = new stream.PassThrough();\n\n                rs.on('error', function (err) {\n                    store.onReadError.call(store, err, fileId, file);\n                    res.end();\n                });\n                ws.on('error', function (err) {\n                    store.onReadError.call(store, err, fileId, file);\n                    res.end();\n                });\n                ws.on('close', function () {\n                    // Close output stream at the end\n                    ws.emit('end');\n                });\n\n                var headers = {\n                    'Content-Type': file.type,\n                    'Content-Length': file.size\n                };\n\n                // Transform stream\n                store.transformRead(rs, ws, fileId, file, req, headers);\n\n                // Parse headers\n                if (typeof req.headers === 'object') {\n                    // Compress data using accept-encoding header\n                    if (typeof req.headers['accept-encoding'] === 'string') {\n                        var accept = req.headers['accept-encoding'];\n\n                        // Compress with gzip\n                        if (accept.match(/\\bgzip\\b/)) {\n                            headers['Content-Encoding'] = 'gzip';\n                            delete headers['Content-Length'];\n                            res.writeHead(200, headers);\n                            ws.pipe(zlib.createGzip()).pipe(res);\n                            return;\n                        }\n                        // Compress with deflate\n                        else if (accept.match(/\\bdeflate\\b/)) {\n                            headers['Content-Encoding'] = 'deflate';\n                            delete headers['Content-Length'];\n                            res.writeHead(200, headers);\n                            ws.pipe(zlib.createDeflate()).pipe(res);\n                            return;\n                        }\n                    }\n                }\n\n                // Send raw data\n                if (!headers['Content-Encoding']) {\n                    res.writeHead(200, headers);\n                    ws.pipe(res);\n                }\n\n            } else {\n                res.end();\n            }\n        });\n\n    } else {\n        next();\n    }\n});\n"]}