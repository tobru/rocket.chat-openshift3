{"version":3,"sources":["meteor://ðŸ’»app/packages/monbro_mongodb-mapreduce-aggregation/packages/monbro_mongodb-mapreduce-aggregation.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6F","file":"/packages/monbro_mongodb-mapreduce-aggregation.js","sourcesContent":["(function () {\n\n///////////////////////////////////////////////////////////////////////////////////////\n//                                                                                   //\n// packages/monbro:mongodb-mapreduce-aggregation/server.coffee.js                    //\n//                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////\n                                                                                     //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar Future, path, tl, _callMapReduce, _dummyCollection_, _futureWrapper;\n\ntl = typeof TLog !== \"undefined\" && TLog !== null ? TLog.getLogger() : void 0;\n\npath = Npm.require(\"path\");\n\nFuture = Npm.require(path.join(\"fibers\", \"future\"));\n\n_dummyCollection_ = new Meteor.Collection('__dummy__');\n\n_futureWrapper = function(collection, commandName, args) {\n  var cb, col, coll1, collectionName, future, result;\n  col = (typeof collection) === \"string\" ? _dummyCollection_ : collection;\n  collectionName = (typeof collection) === \"string\" ? collection : collection._name;\n  coll1 = col.find()._mongo.db.collection(collectionName);\n  future = new Future;\n  cb = future.resolver();\n  args = args.slice();\n  args.push(cb);\n  coll1[commandName].apply(coll1, args);\n  return result = future.wait();\n};\n\n_callMapReduce = function(collection, map, reduce, options) {\n  var col, coll1, collectionName, future, result;\n  col = (typeof collection) === \"string\" ? _dummyCollection_ : collection;\n  collectionName = (typeof collection) === \"string\" ? collection : collection._name;\n  if (tl != null) {\n    tl.debug(\"callMapReduce called for collection \" + collectionName + \" map: \" + map + \" reduce: \" + reduce + (\" options: \" + (JSON.stringify(options))));\n  }\n  coll1 = col.find()._mongo.db.collection(collectionName);\n  future = new Future;\n  coll1.mapReduce(map, reduce, options, function(err, result, stats) {\n    var res;\n    if (err) {\n      future[\"throw\"](err);\n    }\n    res = {\n      collectionName: result.collectionName,\n      stats: stats\n    };\n    return future[\"return\"]([true, res]);\n  });\n  result = future.wait();\n  if (!result[0]) {\n    throw result[1];\n  }\n  return result[1];\n};\n\n_.extend(Meteor.Collection.prototype, {\n  distinct: function(key, query, options) {\n    return _futureWrapper(this._name, \"distinct\", [key, query, options]);\n  },\n  aggregate: function(pipeline) {\n    return _futureWrapper(this._name, \"aggregate\", [pipeline]);\n  },\n  mapReduce: function(map, reduce, options) {\n    options = options || {};\n    options.readPreference = \"primary\";\n    return _callMapReduce(this._name, map, reduce, options);\n  }\n});\n///////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}