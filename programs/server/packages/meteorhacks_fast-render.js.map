{"version":3,"sources":["meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/utils.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/server/namespace.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/server/utils.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/server/routes.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/server/publish_context.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/server/context.js","meteor://ðŸ’»app/packages/meteorhacks_fast-render/lib/server/iron_router_support.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA,sH;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wH;;;;;;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH;;;;;;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wH;;;;;;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wH","file":"/packages/meteorhacks_fast-render.js","sourcesContent":["AddedToChanged = function(localCopy, added) {\n  added.msg = \"changed\";\n  added.cleared = [];\n  added.fields = added.fields || {};\n\n  _.each(localCopy, function(value, key) {\n    if(key != '_id') {\n      if(typeof added.fields[key] == \"undefined\") {\n        added.cleared.push(key);\n      }\n    }\n  });\n};\n\nApplyDDP = function(existing, message) {\n  var newDoc = (!existing)? {}: _.clone(existing);\n  if(message.msg == 'added') {\n    _.each(message.fields, function(value, key) {\n      newDoc[key] = value;\n    });\n  } else if(message.msg == \"changed\") {\n    _.each(message.fields, function(value, key) {\n      newDoc[key] = value;\n    });\n    _.each(message.cleared, function(key) {\n      delete newDoc[key];\n    });\n  } else if(message.msg == \"removed\") {\n    newDoc = null;\n  }\n\n  return newDoc;\n};\n\n// source: https://gist.github.com/kurtmilam/1868955\n//  modified a bit to not to expose this as an _ api\nDeepExtend = function deepExtend (obj) {\n  var parentRE = /#{\\s*?_\\s*?}/,\n      slice = Array.prototype.slice,\n      hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  _.each(slice.call(arguments, 1), function(source) {\n    for (var prop in source) {\n      if (hasOwnProperty.call(source, prop)) {\n        if (_.isNull(obj[prop]) || _.isUndefined(obj[prop]) || _.isFunction(obj[prop]) || _.isNull(source[prop]) || _.isDate(source[prop])) {\n          obj[prop] = source[prop];\n        }\n        else if (_.isString(source[prop]) && parentRE.test(source[prop])) {\n          if (_.isString(obj[prop])) {\n            obj[prop] = source[prop].replace(parentRE, obj[prop]);\n          }\n        }\n        else if (_.isArray(obj[prop]) || _.isArray(source[prop])){\n          if (!_.isArray(obj[prop]) || !_.isArray(source[prop])){\n            throw 'Error: Trying to combine an array with a non-array (' + prop + ')';\n          } else {\n            obj[prop] = _.reject(DeepExtend(obj[prop], source[prop]), function (item) { return _.isNull(item);});\n          }\n        }\n        else if (_.isObject(obj[prop]) || _.isObject(source[prop])){\n          if (!_.isObject(obj[prop]) || !_.isObject(source[prop])){\n            throw 'Error: Trying to combine an object with a non-object (' + prop + ')';\n          } else {\n            obj[prop] = DeepExtend(obj[prop], source[prop]);\n          }\n        } else {\n          obj[prop] = source[prop];\n        }\n      }\n    }\n  });\n  return obj;\n};","FastRender = {\n  _routes: [],\n  _onAllRoutes: []\n};","// meteor algorithm to check if this is a meteor serving http request or not\nIsAppUrl = function (req) {\n  var url = req.url\n  if(url === '/favicon.ico' || url === '/robots.txt') {\n    return false;\n  }\n\n  // NOTE: app.manifest is not a web standard like favicon.ico and\n  // robots.txt. It is a file name we have chosen to use for HTML5\n  // appcache URLs. It is included here to prevent using an appcache\n  // then removing it from poisoning an app permanently. Eventually,\n  // once we have server side routing, this won't be needed as\n  // unknown URLs with return a 404 automatically.\n  if(url === '/app.manifest') {\n    return false;\n  }\n\n  // Avoid serving app HTML for declared routes such as /sockjs/.\n  if(RoutePolicy.classify(url)) {\n    return false;\n  }\n\n  // we only need to support HTML pages only\n  // this is a check to do it\n  return /html/.test(req.headers['accept']);\n};","var Fiber = Npm.require('fibers');\nFastRender._onAllRoutes = [];\nFastRender.frContext = new Meteor.EnvironmentVariable();\n\nvar fastRenderRoutes = Picker.filter(function(req, res) {\n  return IsAppUrl(req);\n});\nfastRenderRoutes.middleware(Npm.require('connect').cookieParser());\nfastRenderRoutes.middleware(function(req, res, next) {\n  FastRender.handleOnAllRoutes(req, res, next);\n});\n\n// handling specific routes\nFastRender.route = function route(path, callback) {\n  if(path.indexOf('/') !== 0){\n    throw new Error('Error: path (' + path + ') must begin with a leading slash \"/\"')\n  }\n  fastRenderRoutes.route(path, FastRender.handleRoute.bind(null, callback));\n};\n\nfunction setQueryDataCallback(res, next) {\n  return function(queryData) {\n    if(!queryData) return next();\n\n    var existingPayload = InjectData.getData(res, \"fast-render-data\");\n    if(!existingPayload) {\n      InjectData.pushData(res, \"fast-render-data\", queryData);\n    } else {\n      // it's possible to execute this callback twice\n      // the we need to merge exisitng data with the new one\n      _.extend(existingPayload.subscriptions, queryData.subscriptions);\n      _.each(queryData.collectionData, function(data, pubName) {\n        var existingData = existingPayload.collectionData[pubName]\n        if(existingData) {\n          data = existingData.concat(data);\n        }\n\n        existingPayload.collectionData[pubName] = data;\n        InjectData.pushData(res, 'fast-render-data', existingPayload);\n      });\n    }\n    next();\n  };\n}\n\nFastRender.handleRoute = function(processingCallback, params, req, res, next) {\n  var afterProcessed = setQueryDataCallback(res, next);\n  FastRender._processRoutes(params, req, processingCallback, afterProcessed);\n};\n\nFastRender.handleOnAllRoutes = function(req, res, next) {\n  var afterProcessed = setQueryDataCallback(res, next);\n  FastRender._processAllRoutes(req, afterProcessed);\n};\n\nFastRender.onAllRoutes = function onAllRoutes(callback) {\n  FastRender._onAllRoutes.push(callback);\n};\n\nFastRender._processRoutes =\n  function _processRoutes(params, req, routeCallback, callback) {\n  callback = callback || function() {};\n\n  var path = req.url;\n  var loginToken = req.cookies['meteor_login_token'];\n  var headers = req.headers;\n\n  var context = new Context(loginToken, { headers: headers });\n\n  try {\n    FastRender.frContext.withValue(context, function() {\n      routeCallback.call(context, params, path);\n    });\n\n    if(context.stop) {\n      return;\n    }\n\n    callback(context.getData());\n  } catch(err) {\n    handleError(err, path, callback);\n  }\n};\n\nFastRender._processAllRoutes =\n  function _processAllRoutes(req, callback) {\n  callback = callback || function() {};\n\n  var path = req.url;\n  var loginToken = req.cookies['meteor_login_token'];\n  var headers = req.headers;\n\n  new Fiber(function() {\n    var context = new Context(loginToken, { headers: headers });\n\n    try {\n      FastRender._onAllRoutes.forEach(function(callback) {\n        callback.call(context, req.url);\n      });\n\n      callback(context.getData());\n    } catch(err) {\n      handleError(err, path, callback);\n    }\n  }).run();\n};\n\nfunction handleError(err, path, callback) {\n  var message =\n    'error on fast-rendering path: ' +\n    path +\n    \" ; error: \" + err.stack;\n  console.error(message);\n  callback(null);\n}\n\n// adding support for null publications\nFastRender.onAllRoutes(function() {\n  var context = this;\n  var nullHandlers = Meteor.default_server.universal_publish_handlers;\n\n  if(nullHandlers) {\n    nullHandlers.forEach(function(publishHandler) {\n      // universal subs have subscription ID, params, and name undefined\n      var publishContext = new PublishContext(context, publishHandler);\n      context.processPublication(publishContext);\n    });\n  }\n});\n","PublishContext = function PublishContext(context, handler, subscriptionId, params, name) {\n  var self = this;\n\n  // mock session\n  var sessionId = Random.id();\n  var session = {\n    id: sessionId,\n    userId: context.userId,\n    // not null\n    inQueue: {},\n    connectionHandle: {\n      id: sessionId,\n      close: function() {},\n      onClose: function() {},\n      clientAddress: \"127.0.0.1\",\n      httpHeaders: context.headers\n    },\n    added: function (subscriptionHandle, collectionName, strId, fields) {\n      // Don't share state with the data passed in by the user.\n      var doc = EJSON.clone(fields);\n      doc._id = self._idFilter.idParse(strId);\n      Meteor._ensure(self._collectionData, collectionName)[strId] = doc;\n    },\n    changed: function (subscriptionHandle, collectionName, strId, fields) {\n      var doc = self._collectionData[collectionName][strId];\n      if (!doc) throw new Error(\"Could not find element with id \" + strId + \" to change\");\n      _.each(fields, function (value, key) {\n        // Publish API ignores _id if present in fields.\n        if (key === \"_id\")\n          return;\n\n        if (value === undefined) {\n          delete doc[key];\n        }\n        else {\n          // Don't share state with the data passed in by the user.\n          doc[key] = EJSON.clone(value);\n        }\n      });\n    },\n    removed: function (subscriptionHandle, collectionName, strId) {\n      if (!(self._collectionData[collectionName] && self._collectionData[collectionName][strId]))\n        new Error(\"Removed nonexistent document \" + strId);\n      delete self._collectionData[collectionName][strId];\n    },\n    sendReady: function (subscriptionIds) {\n      // this is called only for non-universal subscriptions\n      if (!self._subscriptionId) throw new Error(\"Assertion.\");\n\n      // make the subscription be marked as ready\n      if (!self._isDeactivated()) {\n        self._context.completeSubscriptions(self._name, self._params);\n      }\n\n      // we just stop it\n      self.stop();\n    }\n  };\n\n  MeteorX.Subscription.call(self, session, handler, subscriptionId, params, name);\n\n  self.unblock = function() {};\n\n  self._context = context;\n  self._collectionData = {};\n};\n\nPublishContext.prototype = Object.create(MeteorX.Subscription.prototype);\nPublishContext.prototype.constructor = PublishContext;\n\nPublishContext.prototype.stop = function() {\n  // our stop does not remove all documents (it just calls deactivate)\n  // Meteor one removes documents for non-universal subscription\n  // we deactivate both for universal and named subscriptions\n  // hopefully this is right in our case\n  // Meteor does it just for named subscriptions\n  this._deactivate();\n};\n\nPublishContext.prototype.error = function(error) {\n  // TODO: Should we pass the error to the subscription somehow?\n  console.warn('error caught on publication: ', this._name, ': ', (error.message || error));\n  this.stop();\n};\n","var Fibers = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nContext = function Context(loginToken, otherParams) {\n  this._collectionData = {};\n  this._subscriptions = {};\n  this._loginToken = loginToken;\n\n  _.extend(this, otherParams);\n\n  // get the user\n  if(Meteor.users) {\n    // check to make sure, we've the loginToken,\n    // otherwise a random user will fetched from the db\n    if(loginToken) {\n      var hashedToken = loginToken && Accounts._hashLoginToken( loginToken );\n      var query = {'services.resume.loginTokens.hashedToken': hashedToken };\n      var options = {fields: {_id: 1}};\n      var user = Meteor.users.findOne(query, options);\n    }\n\n    // support for Meteor.user\n    Fibers.current._meteor_dynamics = {};\n    Fibers.current._meteor_dynamics[DDP._CurrentInvocation.slot] = this;\n\n    if(user) {\n      this.userId = user._id;\n    }\n  }\n};\n\nContext.prototype.subscribe = function(subName /*, params */) {\n  var self = this;\n\n  var publishHandler = Meteor.default_server.publish_handlers[subName];\n  if(publishHandler) {\n    var params = Array.prototype.slice.call(arguments, 1);\n    // non-universal subs have subscription id\n    var subscriptionId = Random.id();\n    var publishContext = new PublishContext(this, publishHandler, subscriptionId, params, subName);\n\n    return this.processPublication(publishContext);\n  } else {\n    console.warn('There is no such publish handler named:', subName);\n    return {};\n  }\n};\n\nContext.prototype.processPublication = function(publishContext) {\n  var self = this;\n  var data = {};\n  var ensureCollection = function(collectionName) {\n    self._ensureCollection(collectionName);\n    if(!data[collectionName]) {\n      data[collectionName] = [];\n    }\n  };\n\n  var future = new Future();\n  // detect when the context is ready to be sent to the client\n  publishContext.onStop(function() {\n    if(!future.isResolved()) {\n      future.return();\n    }\n  });\n\n  publishContext._runHandler();\n\n  if (!publishContext._subscriptionId) {\n    // universal subscription, we stop it (same as marking it as ready) ourselves\n    // they otherwise do not have ready or stopped state, but in our case they do\n    publishContext.stop();\n  }\n\n  if (!future.isResolved()) {\n    // don't wait forever for handler to fire ready()\n    Meteor.setTimeout(function() {\n      if (!future.isResolved()) {\n        // publish handler failed to send ready signal in time\n        // maybe your non-universal publish handler is not calling this.ready()?\n        // or maybe it is returning null to signal empty publish?\n        // it should still call this.ready() or return an empty array []\n        var message =\n          'Publish handler for ' + publishContext._name +  ' sent no ready signal\\n' +\n          ' This could be because this publication `return null`.\\n' +\n          ' Use `return this.ready()` instead.'\n        console.warn();\n        future.return();\n      }\n    }, 500);  // arbitrarially set timeout to 500ms, should probably be configurable\n\n    //  wait for the subscription became ready.\n    future.wait();\n  }\n\n  // stop any runaway subscription\n  // this can happen if a publish handler never calls ready or stop, for example\n  // it does not hurt to call it multiple times\n  publishContext.stop();\n\n  // get the data\n  _.each(publishContext._collectionData, function(collData, collectionName) {\n    // making an array from a map\n    collData = _.values(collData);\n\n    ensureCollection(collectionName);\n    data[collectionName].push(collData);\n\n    // copy the collection data in publish context into the FR context\n    self._collectionData[collectionName].push(collData);\n  });\n\n  return data;\n};\n\nContext.prototype.completeSubscriptions = function(name, params) {\n  var subs = this._subscriptions[name];\n  if(!subs) {\n    subs = this._subscriptions[name] = {};\n  }\n\n  subs[EJSON.stringify(params)] = true;\n};\n\nContext.prototype._ensureCollection = function(collectionName) {\n  if(!this._collectionData[collectionName]) {\n    this._collectionData[collectionName] = [];\n  }\n};\n\nContext.prototype.getData = function() {\n  return {\n    collectionData: this._collectionData,\n    subscriptions: this._subscriptions,\n    loginToken: this._loginToken\n  };\n};\n\nFastRender._Context = Context;\n","if(!Package['iron:router']) return;\n\nvar RouteController = Package['iron:router'].RouteController;\nvar Router = Package['iron:router'].Router;\n\nvar currentSubscriptions = [];\nMeteor.subscribe = function(subscription) {\n  currentSubscriptions.push(arguments);\n};\n\n//assuming, no runtime routes will be added\nMeteor.startup(function() {\n  // this is trick to run the processRoutes at the \n  // end of all Meteor.startup callbacks\n  Meteor.startup(processRoutes);\n});\n\nfunction processRoutes() {\n  Router.routes.forEach(function(route) {\n    route.options = route.options || {};\n    if(route.options.fastRender) {\n      handleRoute(route);\n    } else if(\n        getController(route) && \n        getController(route).prototype && \n        getController(route).prototype.fastRender\n    ) {\n      handleRoute(route);\n    }\n  });\n\n  // getting global waitOns\n  var globalWaitOns = [];\n  if(Router._globalHooks && Router._globalHooks.waitOn && Router._globalHooks.waitOn.length > 0) {\n    Router._globalHooks.waitOn.forEach(function(waitOn) {\n      globalWaitOns.push(waitOn.hook);\n    });\n  }\n  \n  FastRender.onAllRoutes(function(path) {\n    var self = this;\n    \n    currentSubscriptions = [];\n    globalWaitOns.forEach(function(waitOn) {\n      waitOn.call({path: path});\n    });\n    \n    currentSubscriptions.forEach(function(args) {\n      self.subscribe.apply(self, args);\n    });\n  });\n};\n\nfunction handleRoute(route) {\n  var subscriptionFunctions = [];\n  \n  // get potential subscription handlers from the route options\n  ['waitOn', 'subscriptions'].forEach(function(funcName) {\n    var handler = route.options[funcName];\n    if(typeof handler == 'function') {\n      subscriptionFunctions.push(handler);\n    } else if (handler instanceof Array) {\n      handler.forEach(function(func) {\n        if(typeof func == 'function') {\n          subscriptionFunctions.push(func);\n        }\n      });\n    }\n  });\n\n  FastRender.route(getPath(route), onRoute);\n\n  function onRoute(params, path) {\n    var self = this;\n    var context = {\n      params: params,\n      path: path\n    };\n\n    //reset subscriptions;\n    currentSubscriptions = [];\n    subscriptionFunctions.forEach(function(func) {\n      func.call(context);\n    });\n\n    // if there is a controller, try to initiate it and invoke potential \n    // methods which could give us subscriptions\n    var controller = getController(route);\n    if(controller && controller.prototype) {\n      if(typeof controller.prototype.lookupOption == 'function') {\n        // for IR 1.0\n        // it is possible to create a controller invoke methods on it\n        var controllerInstance = new controller();\n        controllerInstance.params = params;\n        controllerInstance.path = path;\n\n        ['waitOn', 'subscriptions'].forEach(function(funcName) {\n          if(controllerInstance[funcName]) {\n            controllerInstance[funcName].call(controllerInstance);\n          }\n        });\n      } else {\n        // IR 0.9\n        // hard to create a controller instance\n        // so this is the option we can take\n        var waitOn = controller.prototype.waitOn;\n        if(waitOn) {\n          waitOn.call(context);\n        }\n      }\n    }\n\n    currentSubscriptions.forEach(function(args) {\n      self.subscribe.apply(self, args);\n    });\n  }\n}\n\nfunction getPath(route) {\n  if(route._path) {\n    // for IR 1.0\n    return route._path;\n  } else {\n    // for IR 0.9\n    var name = (route.name == \"/\")? \"\" : name;\n    return route.options.path || (\"/\" + name);\n  }\n}\n\nfunction getController(route) {\n  if(route.findControllerConstructor) {\n    // for IR 1.0\n    return route.findControllerConstructor();\n  } else if(route.findController) {\n    // for IR 0.9\n    return route.findController();\n  } else {\n    // unsupported version of IR\n    return null;\n  }\n}"]}