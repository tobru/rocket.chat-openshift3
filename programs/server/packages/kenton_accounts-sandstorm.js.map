{"version":3,"sources":["meteor://ðŸ’»app/packages/kenton_accounts-sandstorm/server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gH","file":"/packages/kenton_accounts-sandstorm.js","sourcesContent":["// Copyright (c) 2014 Sandstorm Development Group, Inc. and contributors\n// Licensed under the MIT License:\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nif (process.env.SANDSTORM) {\n  __meteor_runtime_config__.SANDSTORM = true;\n}\n\nif (__meteor_runtime_config__.SANDSTORM) {\n  if (Package[\"accounts-base\"]) {\n    // Highlander Mode: Disable all non-Sandstorm login mechanisms.\n    Package[\"accounts-base\"].Accounts.validateLoginAttempt(function (attempt) {\n      if (!attempt.allowed) {\n        return false;\n      }\n      if (attempt.type !== \"sandstorm\") {\n        throw new Meteor.Error(403, \"Non-Sandstorm login mechanisms disabled on Sandstorm.\");\n      }\n      return true;\n    });\n    Package[\"accounts-base\"].Accounts.validateNewUser(function (user) {\n      if (!user.services.sandstorm) {\n        throw new Meteor.Error(403, \"Non-Sandstorm login mechanisms disabled on Sandstorm.\");\n      }\n      return true;\n    });\n  }\n\n  var Future = Npm.require(\"fibers/future\");\n\n  var inMeteor = Meteor.bindEnvironment(function (callback) {\n    callback();\n  });\n\n  var logins = {};\n  // Maps tokens to currently-waiting login method calls.\n\n  if (Package[\"accounts-base\"]) {\n    Meteor.users._ensureIndex(\"services.sandstorm.id\", {unique: 1, sparse: 1});\n  }\n\n  Meteor.onConnection(function (connection) {\n    connection._sandstormUser = null;\n    connection.sandstormUser = function () {\n      if (!connection._sandstormUser) {\n        throw new Meteor.Error(400, \"Client did not complete authentication handshake.\");\n      }\n      return this._sandstormUser;\n    };\n  });\n\n  Meteor.methods({\n    loginWithSandstorm: function (token) {\n      check(token, String);\n\n      var future = new Future();\n\n      logins[token] = future;\n\n      var timeout = setTimeout(function () {\n        future.throw(new Meteor.Error(\"timeout\", \"Gave up waiting for login rendezvous XHR.\"));\n      }, 10000);\n\n      var info;\n      try {\n        info = future.wait();\n      } finally {\n        clearTimeout(timeout);\n        delete logins[token];\n      }\n\n      // Set connection info. The call to setUserId() resets all publishes. We update the\n      // connection's sandstorm info first so that when the publishes are re-run they'll see the\n      // new info. In theory we really want to update it exactly when this.userId is updated, but\n      // we'd have to dig into Meteor internals to pull that off. Probably updating it a little\n      // early is fine?\n      //\n      // Note that calling setUserId() with the same ID a second time still goes through the motions\n      // of restarting all subscriptions, which is important if the permissions changed. Hopefully\n      // Meteor won't decide to \"optimize\" this by returning early if the user ID hasn't changed.\n      this.connection._sandstormUser = info.sandstorm;\n      this.setUserId(info.userId);\n\n      return info;\n    }\n  });\n\n  WebApp.rawConnectHandlers.use(function (req, res, next) {\n    if (req.url === \"/.sandstorm-login\") {\n      handlePostToken(req, res);\n      return;\n    }\n    return next();\n  });\n\n  function readAll(stream) {\n    var future = new Future();\n\n    var chunks = [];\n    stream.on(\"data\", function (chunk) {\n      chunks.push(chunk.toString());\n    });\n    stream.on(\"error\", function (err) {\n      future.throw(err);\n    });\n    stream.on(\"end\", function () {\n      future.return();\n    });\n\n    future.wait();\n\n    return chunks.join(\"\");\n  }\n\n  var handlePostToken = Meteor.bindEnvironment(function (req, res) {\n    inMeteor(function () {\n      try {\n        // Note that cross-origin POSTs cannot set arbitrary Content-Types without explicit CORS\n        // permission, so this effectively prevents XSRF.\n        if (req.headers[\"content-type\"].split(\";\")[0].trim() !== \"application/x-sandstorm-login-token\") {\n          throw new Error(\"wrong Content-Type for .sandstorm-login: \" + req.headers[\"content-type\"]);\n        }\n\n        var token = readAll(req);\n\n        var future = logins[token];\n        if (!future) {\n          throw new Error(\"no current login request matching token\");\n        }\n\n        var permissions = req.headers[\"x-sandstorm-permissions\"];\n        if (permissions && permissions !== \"\") {\n          permissions = permissions.split(\",\");\n        } else {\n          permissions = [];\n        }\n\n        var sandstormInfo = {\n          id: req.headers[\"x-sandstorm-user-id\"] || null,\n          name: decodeURI(req.headers[\"x-sandstorm-username\"]),\n          permissions: permissions,\n          picture: req.headers[\"x-sandstorm-user-picture\"] || null,\n          preferredHandle: req.headers[\"x-sandstorm-preferred-handle\"] || null,\n          pronouns: req.headers[\"x-sandstorm-user-pronouns\"] || null\n        };\n\n        var userInfo = {sandstorm: sandstormInfo};\n        if (Package[\"accounts-base\"]) {\n          if (sandstormInfo.id) {\n            // The user is logged into Sansdtorm. Create a Meteor account for them, or find the\n            // existing one, and record the user ID.\n            var login = Package[\"accounts-base\"].Accounts.updateOrCreateUserFromExternalService(\n              \"sandstorm\", sandstormInfo, {profile: {name: sandstormInfo.name}});\n            userInfo.userId = login.userId;\n          } else {\n            userInfo.userId = null;\n          }\n        } else {\n          // Since the app isn't using regular Meteor accounts, we can define Meteor.userId()\n          // however we want.\n          userInfo.userId = sandstormInfo.id;\n        }\n\n        future.return(userInfo);\n        res.writeHead(204, {});\n        res.end();\n      } catch (err) {\n        res.writeHead(500, {\n          \"Content-Type\": \"text/plain\"\n        });\n        res.end(err.stack);\n      }\n    });\n  });\n}\n"]}